[/
    Copyright (c) 2021  Vinnie Falco (vinnie.falco@gmail.com)
    Copyright (c) 2019 Alan Freitas (alandefreitas@gmail.com)

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

    Official repository: https://github.com/CPPAlliance/url
]

[section Quick Look]

[heading Headers]

This section is intended to give the reader a brief overview of the features
and interface style of the library. We begin by including the library header file which brings all the symbols into
scope.

[c++]
[snippet_headers_1]

Alternatively, individual headers may be included to obtain the declarations
 for specific types.

[heading Linking]

You will need to link your program with the Boost.URL built library. You must install binaries
in a location that can be found by your linker.

If you followed the [@http://www.boost.org/doc/libs/release/more/getting_started/index.html Boost Getting Started]
instructions, that's already been done for you.

[heading Header-only]

Boost.URL can also be used as a header-only library. Simply provide the Boost directory to your
compiler and include this in ['exactly one] of your source files:

[c++]
```
    #include <boost/url/src.hpp>
```

[note
    The "header-only" configuration needs `BOOST_URL_NO_LIB` defined when building with MSVC. This macro will instruct
    Boost to deactivate auto-linking on MSVC.

    [c++]
    ```
        #define BOOST_URL_NO_LIB
        #include <boost/url.hpp>
    ```
]


[heading Parsing]

Say you have the following URL that you want to parse:

[c++]
[snippet_parsing_1]

You can parse it by calling this function:

[snippet_parsing_2]

[note
    Sample code and identifiers used throughout are written as if
    the following declarations are in effect:

    [snippet_headers_3]
]

The function __parse_uri__ returns an object of type `__result__<__url_view__>`
which is a container resembling a variant that holds either an error or an object.

We can immediately call `result::value` to obtain a __url_view__.

[snippet_parsing_3]

`result::value` throws an exception on a parsing error.

[snippet_parsing_4]

Alternatively, the functions `result::has_value` and
`result::has_error` could also be used to check if
the string has been parsed without errors.

[snippet_parsing_5]

When there are no errors, it `result::value` returns an instance of __url_view__,
which holds the parsed result.

[note
    It is worth noting that __parse_uri__ allocates no memory and throws no exceptions.
    Like a __string_view__, a __url_view__ does not retain ownership of the underlying
    string buffer. Constructed URL views always contain a valid URL in its correctly
    serialized form.
]

[heading Accessing]

Accessing the parts of the URL is easy:

[table [[Code][Output]] [[
[c++]
[snippet_accessing_1]
][
[teletype]
```
    scheme    : https
    authority : user:pass@www.example.com:443
    path      : /path/to/my%2dfile.txt
    query     : id=42&name=John%20Doe
    fragment  : page%20anchor
```
]]]

Functions like
[link url.ref.boost__urls__url_view.encoded_query `encoded_query`]
return string views, simply referencing the relevant portion of the
URL string without the need to allocate memory.

These functions might return empty strings both for empty and absent
components.

[table [[Code][Output]] [[
[c++]
[snippet_accessing_2]
][
[teletype]
```
    fragment 1 :

    fragment 2 :
```
]]]

To differentiate between empty and absent components, we can use
functions such as [link url.ref.boost__urls__url_view.has_fragment `has_fragment`]:

[table [[Code][Output]] [[
[c++]
[snippet_accessing_2]
][
[teletype]
```
    has fragment 1 : 0
    fragment 1 :

    has fragment 2 : 1
    fragment 2 :

```
]]]

[heading Decoding]

To get a decoded string, most observers provide the corresponding
function without the word `encoded`:

[table [[Code][Output]] [[
[c++]
[snippet_decoding_1]
][
[teletype]
```
    query    : id=42&name=John Doe
    fragment : page anchor
```
]]]

The decoded functions return a __const_string__, which is a library type
that models a read-only string. This class retains ownership of the
underlying buffer and uses a type-erased allocator.

These are the encoded versions of the observers:

[table [[Component][Decoded][Encoded][Check]]
[
    [authority]
    []
    [[link url.ref.boost__urls__url_view.encoded_authority `encoded_authority`]]
    [[link url.ref.boost__urls__url_view.has_authority `has_authority`]]]

[
    [fragment]
    [[link url.ref.boost__urls__url_view.fragment `fragment`]]
    [[link url.ref.boost__urls__url_view.encoded_fragment `encoded_fragment`]]
    [[link url.ref.boost__urls__url_view.has_fragment `has_fragment`]]
]
[
    [host]
    [[link url.ref.boost__urls__url_view.host `host`]]
    [[link url.ref.boost__urls__url_view.encoded_host `encoded_host`]]
    []
]
[
    [host_and_port]
    []
    [[link url.ref.boost__urls__url_view.encoded_host_and_port `encoded_host_and_port`]]
    []
]
[
    [origin]
    []
    [[link url.ref.boost__urls__url_view.encoded_origin `encoded_origin`]]
    []
]
[
    [params]
    [[link url.ref.boost__urls__url_view.params `params`]]
    [[link url.ref.boost__urls__url_view.encoded_params `encoded_params`]]
    []
]
[
    [password]
    [[link url.ref.boost__urls__url_view.password `password`]]
    [[link url.ref.boost__urls__url_view.encoded_password `encoded_password`]]
    [[link url.ref.boost__urls__url_view.has_password `has_password`]]
]
[
    [path]
    []
    [[link url.ref.boost__urls__url_view.encoded_path `encoded_path`]]
    []
]
[
    [query]
    [[link url.ref.boost__urls__url_view.query `query`]]
    [[link url.ref.boost__urls__url_view.encoded_query `encoded_query`]]
    [[link url.ref.boost__urls__url_view.has_query `has_query`]]
]
[
    [segments]
    [[link url.ref.boost__urls__url_view.segments `segments`]]
    [[link url.ref.boost__urls__url_view.encoded_segments `encoded_segments`]]
    []
]
[
    [user]
    [[link url.ref.boost__urls__url_view.user `user`]]
    [[link url.ref.boost__urls__url_view.encoded_user `encoded_user`]]
    []
]
[
    [userinfo]
    [[link url.ref.boost__urls__url_view.userinfo `userinfo`]]
    [[link url.ref.boost__urls__url_view.encoded_userinfo `encoded_userinfo`]]
    [[link url.ref.boost__urls__url_view.has_userinfo `has_userinfo`]]
]
]

Note that __url_view__ does not provide decoded functions for
[link compound-elements compound elements], such as
[link url.ref.boost__urls__url_view.encoded_authority `encoded_authority`]
and [link url.ref.boost__urls__url_view.encoded_path `encoded_path`].
Compound elements are made up of multiple sub-elements whose encoded delimiters might be ambiguous.

Many components also do not have corresponding functions such as
[link url.ref.boost__urls__url_view.has_authority `has_authority`]
to check for their existence. This happens because some URL
components are mandatory.

Although URL query strings are often used to represent key/value pairs, they
are not a compound element because this interpretation is not defined by
__rfc3986__. Users can treat the query as a single entity.
__url_view__ provides the function
[link url.ref.boost__urls__url_view.params `params`] to extract this view
of key/value pairs.

[heading Allocators]

All functions that return __const_string__ accept an optional __Allocator__.
When omitted, this parameter defaults to the standard allocator.

Here is the same code which prints the query with percent-decoding applied,
except using a local stack-based allocator instead of the heap:

[table [[Code][Output]] [[
[c++]
[snippet_allocators_1]
][
[teletype]
```
    query    : id=42&name=John Doe
    fragment : page anchor
```
]]]

The __static_pool__ type is provided by the library as an easy alternative
to apply percent-decoding to long strings with no memory allocations.

[#compound-elements]
[heading Compound elements]

The path and query parts of the URL are treated specially by the library.
While they can be accessed as individual encoded strings, they can also be
accessed through special view types which act as bidirectional ranges.

This code calls
[link url.ref.boost__urls__url_view.encoded_segments `encoded_segments`]
to obtain the path segments as a container that returns encoded strings:
[table [[Code][Output]] [[
[c++]
[snippet_compound_elements_1]
][
```
    path
    to
    my%2dfile.txt
```
]]]

As with other __url_view__ functions which return encoded strings, the encoded
segments container does not allocate memory. Instead it returns views to the
corresponding portions of the underlying encoded buffer referenced by the URL.

[heading Encoded compound elements]

Alternatively, the function [link url.ref.boost__urls__url_view.segments `segments`]
may be called to obtain the path segments as strings with percent-decoding
applied, which requires allocating memory.

With no arguments the container returns strings using the default allocator:

[table [[Code][Output]] [[
[c++]
[snippet_encoded_compound_elements_1]
][
[teletype]
```
    path
    to
    my-file.txt
```
]]]

Memory allocations can be avoided entirely by passing a suitable allocator
when acquiring the container:

[table [[Code][Output]] [[
[c++]
[snippet_encoded_compound_elements_2]
][
[teletype]
```
    path
    to
    my-file.txt
```
]]]


The query parameters can be accessed similarly, Here we access the parameters
as percent-encoded key and value pair strings:

[table [[Code][Output]] [[
[c++]
[snippet_encoded_compound_elements_3]
][
[teletype]
```
    key = id, value = 42
    key = name, value = John%20Doe
```
]]]

Obtaining encoded strings from URLs never needs to allocate memory. Here we
obtain the query parameters as allocated strings with percent-decoding applied,
using a stack-based allocator which does not use the heap:
[table [[Code][Output]] [[
[c++]
[snippet_encoded_compound_elements_4]
][
[teletype]
```
    key = id, value = 42
    key = name, value = John Doe
```
]]]

[/-----------------------------------------------------------------------------]

[heading Modification]

The library provides the container __url__ for supporting modification of the
contents of a URL. Unlike the __url_view__, which does not gain ownership of
the underlying character buffer, the __url__ container uses the default
allocator to control a resizable character buffer which it owns.

A __url__ must be constructed from an existing __url_view__. For example using a parse function:

[c++]
[snippet_modification_1]

Objects of type __url__ are first-class. They can be copied, moved, and
assigned as needed. They support all of the inspection functions of
__url_view__, and also provide functions to modify all parts of the URL.


Changing the scheme is easy:

[snippet_modification_2]

Or we can use a predefined constant:

[snippet_modification_3]

The scheme must be valid, however, or an exception is thrown:

[snippet_modification_4]

All modification functions perform validation on their input. Attemping
to set part of the URL to an invalid string will result in an exception.
It is not possible for a __url__ to hold a syntactically illegal text.

Modification functions return a reference to the object, so chaining
is possible:

[snippet_modification_5]

All non-const operations offer the strong exception safety guarantee.

The path segment and query parameter containers returned by __url__ offer
modifiable range functionality, using member functions of the container:

[table [[Code][Output]] [[
[c++]
[snippet_modification_6]
][
[teletype]
```
    https://192.168.0.1:8080/path/to/my%2dfile.txt?id=42&name=Vinnie%20Falco#page%20anchor
```
]]]

[endsect]

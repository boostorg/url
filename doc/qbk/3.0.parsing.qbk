[/
    Copyright (c) 2019 Vinnie Falco (vinnie.falco@gmail.com)

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

    Official repository: https://github.com/CPPAlliance/url
]

[section URL]

[h5 Notation]

This library standardizes on the term "URL" to refer to all strings which
follow the syntax in __rfc3986__. The reason is that the terms URI and IRI
cause confusion. In practice a single algorithm is used for both so
keeping them distinct yields little value. When discussing particular
grammars, the name of the grammar is used exactly as it appears in the
literature.

A URL string can be parsed using one of the parsing functions.
Each function parses according to a particular grammar specified
in __rfc3986__:

[table Parsing Functions [
    [Function]
    [Grammar]
][
    [[link url.ref.boost__urls__parse_absolute_uri `parse_absolute_uri`]]
    [[@https://datatracker.ietf.org/doc/html/rfc3986#section-4.3 ['absolute-URI]]]
][
    [[link url.ref.boost__urls__parse_relative_ref `parse_relative_ref`]]
    [[@https://datatracker.ietf.org/doc/html/rfc3986#section-4.2 ['relative-ref]]]
][
    [[link url.ref.boost__urls__parse_uri `parse_uri`]]
    [[@https://datatracker.ietf.org/doc/html/rfc3986#section-3 ['URI]]]
][
    [[link url.ref.boost__urls__parse_uri_reference `parse_uri_reference`]]
    [[@https://datatracker.ietf.org/doc/html/rfc3986#section-4.1 ['URI-reference]]]
]]

The collective grammars parsed by these algorithms are specified below.

[teletype]
```
    absolute-URI    = scheme ":" hier-part [ "?" query ]

    relative-ref    = relative-part [ "?" query ] [ "#" fragment ]

    URI             = scheme ":" hier-part [ "?" query ] [ "#" fragment ]

    URI-reference   = URI / relative-ref

    hier-part       = "//" authority path-abempty
                    / path-absolute
                    / path-rootless
                    / path-empty

    relative-part   = "//" authority path-abempty
                    / path-absolute
                    / path-noscheme
                    / path-empty
```

The following is an example URI and its main parts:

[teletype]
```
     foo://example.com:8042/over/there?name=ferret#nose
     \_/   \______________/\_________/ \_________/ \__/
      |           |            |            |        |
scheme     authority       path        query   fragment
```


For the complete specification please refer to __rfc3986__:

[note
    This documentation refers to the Augmented Backus-Naur Form (ABNF)
    notation of
    [@https://tools.ietf.org/html/rfc2234 rfc2234]
    to specify particular grammars used by algorithms and containers. While
    a complete understanding of the notation is not a requirement for using the
    library, it may help for understanding how valid components of URLs are
    defined. In particular, this will be of interest to users who wish to
    compose parsing algorithms using the combinators provided by the library.
]

[h5 Functions]

All parsing functions accept a __string_view__ and return a
`__result__<__url_view__>`. The following example parses a string literal
containing a URI:

[c++]
[snippet_parsing_url_1]

The function throws nothing and returns the result in a variant-like container
which holds a __url_view__ or an __error_code__ in the case where the parsing
failed. Note that like a string view, the URL view does not own the underlying
character buffer. Instead, it references the string passed to the parsing
function. The caller is required to ensure that the lifetime of the string
extends until the view is destroyed.

[h5 Creating copies]

The function
[link url.ref.boost__urls__url_view.collect `url_view::collect`]
may be used to create a copy of the underlying character buffer and attach
ownership of the buffer to a newly returned view, which is wrapped in a
shared pointer. The following code calls `collect` to create a read-only
copy:

[c++]
[snippet_parsing_url_2]

The interface of __url_view__ decomposes the URL into its individual parts and
allows for inspection of the various parts as well as returning metadata about
the URL itself. These non-modifying observer operations are described in the
sections that follow.

[h5 Return Type]

In many places, functions in the library have a return type which uses the
__result__ alias template. This class allows the parsing algorithms to
report errors without recurring to exceptions.

Below is a synopsis of the type. For complete information please consult the
 full `result` documentation in Boost.System:

```
    // A variant-like object which hold the
    // value T upon success, otherwise holds
    // an ``__error_code__``.
    //
    template< class T >
    class ``__result__``
    {
    public:
        // Return true if the result contains an error
        constexpr bool has_error() const noexcept;

        // These return true if the result contains a value
        constexpr bool has_value() const noexcept;
        constexpr explicit operator bool() const noexcept;

        // Return the value or throw an exception if has_value()==false
        constexpr T& value();
        constexpr T& operator*();
        constexpr T const& value() const;
        constexpr T const& operator*() const;

        // Return the error, which is default constructed if has_error()==false
        constexpr ``__error_code__`` error() const noexcept;

        ``['more...]``
```

[endsect]